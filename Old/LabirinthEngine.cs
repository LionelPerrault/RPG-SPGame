using System;
using System.ComponentModel;
//using System.ServiceModel.Configuration;
using System.Text;
using System.IO;
using System.Threading;
using System.Diagnostics;

namespace Rogue
{
    public static class LabirinthEngine
    {
        private static Random r = new Random();
        //class myClass : ICloneable
        //{
        //    public String test;
        //    public object Clone()
        //    {
        //        return this.MemberwiseClone();
        //    }
        //}

        // *** описание списка: конец
        // *** проверка допустимости пробива поля: начало
        public static bool valid_proboi(char c)
        {
            if ((c == '2') || (c == '0'))
                return true;
            else
                return false;
        }
        // *** проверка допустимости пробива поля: конец
        // *** проверка соседнего с пробивом поля: начало
        public static bool valid_sosed(char c)
        {
            if ((c == '1') || (c == '2') || (c == '0') || (c == '#'))
                return true;
            else
                return false;
        }
        // *** проверка соседнего с пробивом поля: конец
        // *** заполняем комнату: начало
        public static void fill_room(ref StringBuilder[][] Maz, int x, int y, TList list)
        {
            // заполнять будем по рекурсивному алгоритму:
            Maz[x][y] = new StringBuilder(".");
            // и добавлять заполненные узловые точки в список list:
            if ((x % 2 == 1) && (y % 2 == 1))
                list.add_node(x, y);
            // а расширяться будем во все стороны где нули:
            // север:
            if (Maz[x][y - 1].ToString() == "0")
            {
                fill_room(ref Maz, x, y - 1, list);
            }
            // запад:
            if (Maz[x - 1][y].ToString() == "0")
            {
                fill_room(ref Maz, x - 1, y, list);
            }
            // юг:
            if (Maz[x][y + 1].ToString() == "0")
            {
                fill_room(ref Maz, x, y + 1, list);
            }
            // восток:
            if (Maz[x + 1][y].ToString() == "0")
            {
                fill_room(ref Maz, x + 1, y, list);
            }
        }
        // *** заполняем комнату: конец
        // *** заполняем массив стенами "#" и пустотами ".": начало
        public static void generate(ref StringBuilder[][] Maz, int max_x, int max_y, TCoord first_field)
        {
            // создаём список:
            TList list = new TList();
            // вспомогательные переменные:
            TCoord coord = new TCoord(); // для координат
            string dir = new string(new char[4]); // для направлений с з ю в
            int r;
            int i;
            // инициализация генератора псевдослучайных чисел значением текущего времени
            RandomNumbers.Seed();
            // ----------------------------------------------------------------------------------------
            // ------------- весь алгоритм генерации- здесь: ------------------------------------------
            // ----------------------------------------------------------------------------------------
            // выбираем начальное поле:
            coord.x = first_field.x;
            coord.y = first_field.y;
            Maz[coord.x][coord.y] = new StringBuilder("@");
            // заносим поле в список:
            list.add_node(coord.x, coord.y);
            // основной цикл генерации:
            do
            {
                // выбираем наугад поле из списка:
                r = RandomNumbers.NextNumber() % list.nodes_num;
                coord = list.get_node(r);
                // считаем направления,
                // куда с этого поля можно расшириться:
                i = 0;
                // север:
                if ((coord.y > 2) && (Maz[coord.x][coord.y - 2].ToString() == "2") || (coord.y > 2) && (Maz[coord.x][coord.y - 2].ToString() == "0"))
                {
                    dir = StringHelper.ChangeCharacter(dir, i, 'с');
                    i++;
                }
                // запад:
                if ((coord.x > 2) && (Maz[coord.x - 2][coord.y].ToString() == "2") || (coord.x > 2) && (Maz[coord.x - 2][coord.y].ToString() == "0"))
                {
                    dir = StringHelper.ChangeCharacter(dir, i, 'з');
                    i++;
                }
                // юг:
                if ((coord.y < (max_y - 3)) && (Maz[coord.x][coord.y + 2].ToString() == "2") || (coord.y < (max_y - 3)) && (Maz[coord.x][coord.y + 2].ToString() == "0"))
                {
                    dir = StringHelper.ChangeCharacter(dir, i, 'ю');
                    i++;
                }
                // восток:
                if ((coord.x < (max_x - 3)) && (Maz[coord.x + 2][coord.y].ToString() == "2") || (coord.x < (max_x - 3)) && (Maz[coord.x + 2][coord.y].ToString() == "0"))
                {
                    dir = StringHelper.ChangeCharacter(dir, i, 'в');
                    i++;
                }
                // если некуда расширяться,
                //то выкидываем выбранное поле из списка:
                if (i == 0)
                {
                    list.del_node(r, list);
                }
                else
                {
                    // иначе- расширяемся куда-нибудь:
                    i = RandomNumbers.NextNumber() % i;
                    if (dir[i] == 'с')
                    {
                        Maz[coord.x][coord.y - 1] = new StringBuilder(".");
                        if (Maz[coord.x][coord.y - 2].ToString() == "0")
                        {
                            // заполняем комнату
                            fill_room(ref Maz, coord.x, coord.y - 2, list);
                            // отмечаем, что заносить новое поле в список уже не надо:
                            coord.x = -1;
                        }
                        else
                        {
                            // пробиваемся на север:
                            Maz[coord.x][coord.y - 2] = new StringBuilder(".");
                            // координаты нового поля:
                            coord.y = coord.y - 2;
                        }
                    }
                    if (dir[i] == 'з')
                    {
                        Maz[coord.x - 1][coord.y] = new StringBuilder(".");
                        if (Maz[coord.x - 2][coord.y].ToString() == "0")
                        {
                            // заполняем комнату
                            fill_room(ref Maz, coord.x - 2, coord.y, list);
                            // отмечаем, что заносить новое поле в список уже не надо:
                            coord.x = -1;
                        }
                        else
                        {
                            // пробиваемся на запад:
                            Maz[coord.x - 2][coord.y] = new StringBuilder(".");
                            // координаты нового поля:
                            coord.x = coord.x - 2;
                        }
                    }
                    if (dir[i] == 'ю')
                    {
                        Maz[coord.x][coord.y + 1] = new StringBuilder(".");
                        if (Maz[coord.x][coord.y + 2].ToString() == "0")
                        {
                            // заполняем комнату
                            fill_room(ref Maz, coord.x, coord.y + 2, list);
                            // отмечаем, что заносить новое поле в список уже не надо:
                            coord.x = -1;
                        }
                        else
                        {
                            // пробиваемся на юг:
                            Maz[coord.x][coord.y + 2] = new StringBuilder(".");
                            // координаты нового поля:
                            coord.y = coord.y + 2;
                        }
                    }
                    if (dir[i] == 'в')
                    {
                        Maz[coord.x + 1][coord.y] = new StringBuilder(".");
                        if (Maz[coord.x + 2][coord.y].ToString() == "0")
                        {
                            // заполняем комнату
                            fill_room(ref Maz, coord.x + 2, coord.y, list);
                            // отмечаем, что заносить новое поле в список уже не надо:
                            coord.x = -1;
                        }
                        else
                        {
                            // пробиваемся на восток:
                            Maz[coord.x + 2][coord.y] = new StringBuilder(".");
                            // координаты нового поля:
                            coord.x = coord.x + 2;
                        }
                    }
                    // и заносим новое поле в список:
                    if (coord.x != -1)
                        list.add_node(coord.x, coord.y);
                }
                // крутим основной цикл, пока список не пуст:
            } while (list.head != null);
            // ----------------------------------------------------------------------------------------
            // ----------------------------------------------------------------------------------------
            // ----------------------------------------------------------------------------------------
            // лабиринт готов, но нужно ещё заменить оставшиеся цифры стенами:
            for (int y = 0; y < max_y; y++)
            {
                for (int x = 0; x < max_x; x++)
                {
                    if ((Maz[x][y].ToString() == "1") || (Maz[x][y].ToString() == "2"))
                        Maz[x][y] = new StringBuilder("#");
                }
            }
            File.Delete(Directory.GetCurrentDirectory() + "\\template.txt");
        }
        // *** заполняем массив стенами "#" и пустотами ".": конец
        // *** выводим массив в файл: начало
        public static int output(ref StringBuilder[][] Maz, int max_x, int max_y,int level,bool Capital=false,int Quarter=0,bool Opening=false)
        {
            #region old
            //FileStream fs = new FileStream(Directory.GetCurrentDirectory() + "\\outputs.txt", FileMode.Create);
            //StreamWriter sw = new StreamWriter(fs, Encoding.Default);
            // открываем файл для записи:
            //file = fopen(output_name, "w");
            // и в цикле выводим каждую ячейку:
            //for (int y = 0; y < max_y; y++)
            //{
                //for (int x = 0; x < max_x; x++)
                //{
                    //sw.Write(Maz[x][y]);
                    //fputc(Maz[x][y],file);
                //}
                // в конце каждой строчки переводим строку:
                //fputc("\n",file);
                //sw.WriteLine();
            //}
            #endregion

            MechEngine.Labirinth Lab = new MechEngine.Labirinth();
            MechEngine.Labirinth.Cell[][] StLab = new MechEngine.Labirinth.Cell[max_x][];
            //Lab.Map = StLab;
            for (int i = 0; i < max_x; i++)
                StLab[i] = new MechEngine.Labirinth.Cell[max_y];
            for (int y = 0; y < max_y; y++)
            {                
                for (int x = 0; x < max_x; x++)
                {
                    if (Maz[x][y].ToString() == "#")
                    {
                        StLab[x][y] = new MechEngine.Labirinth.Cell();
                        StLab[x][y].Wall = new MechEngine.Wall();
                        StLab[x][y].Vision = '#';         
                    }
                    else if (Maz[x][y].ToString() == ".")
                    {
                        StLab[x][y] = new MechEngine.Labirinth.Cell();
                        StLab[x][y].Empty = true;
                        StLab[x][y].Vision = ' ';
                    }
                    else if (Maz[x][y].ToString() == Rogue.RAM.Player.Icon.ToString())
                    {
                        StLab[x][y] = new MechEngine.Labirinth.Cell();
                        StLab[x][y].Empty = true;
                        StLab[x][y].Vision = ' ';
                    }
                    else
                    {
                        StLab[x][y] = new MechEngine.Labirinth.Cell();
                    }
                    //sw.Write(StLab[x][y].Vision);
                }
                //sw.WriteLine();
            }
            Lab.Map = StLab;
            Lab.Level = level;
            Rogue.RAM.Map = Lab;
            if (!Opening)
            {
                if (!Capital)
                {
                    LabirinthEngine.CharEnemyLootEngine.CreateCharacter();
                    LabirinthEngine.CharEnemyLootEngine.CreateBiom();
                    LabirinthEngine.CharEnemyLootEngine.CreateEnemys();
                    LabirinthEngine.CharEnemyLootEngine.CreateItems();
                    LabirinthEngine.CharEnemyLootEngine.CreateEnterOuter();
                    LabirinthEngine.CharEnemyLootEngine.CreateDoors();
                    LabirinthEngine.CharEnemyLootEngine.CreatePoisons();
                    LabirinthEngine.CharEnemyLootEngine.CreateObjects();
                    LabirinthEngine.CharEnemyLootEngine.CreateBosses();
                }
                else
                {
                    CapitalEngine.CreateChar = Quarter;
                    CapitalEngine.CreateNpc = Quarter;
                    Rogue.RAM.Map.Biom = ConsoleColor.DarkGray;
                    Rogue.RAM.Map.Name = "Мраумир - " + Template.Postfix;
                    Rogue.RAM.Map._Name = "Мраумир";
                }
            }
            else
            {
                CapitalEngine.CharLEARN();
                CapitalEngine.NpcLEARN();
                Rogue.RAM.Map.Biom = ConsoleColor.White;
                Rogue.RAM.Map.Name = "Святилище";
                Rogue.RAM.Map._Name = "Святилище";
            }
            DrawEngine.InfoWindow.Location(Rogue.RAM.Map.Name);

            #region old
            // закрываем файл:
            //fclose(file);
            //sw.Close();
            //fs.Close();
            // успешное завершение функции:
            #endregion

            return 0;
        }
        // *** выводим массив в файл: конец
        // *** читаем шаблон массива: начало
        public static TCoord get_shablon(ref StringBuilder[][] Maz, int max_x, int max_y, ref string input_name)
        {
            FileStream fs = new FileStream(Directory.GetCurrentDirectory() + "\\template.txt", FileMode.Open);
            StreamReader sr = new StreamReader(fs, Encoding.Default);
            string str = new string(new char[256]);
            char c;
            // координаты входа:
            //max_y = max_y - 1;
            TCoord coord = new TCoord();
            coord.x = -1;
            coord.y = -1;
            // пропускаем инфу о размере лабиринта:
            str = sr.ReadLine();
            str = sr.ReadLine();
            int x = 0; // столбцы и строки
            int y = 0;

            do
            {
                c = (char)sr.Read();
                if (x == max_x)
                { y++; x = 0; }
                if (c != '\n')
                {
                    if (c == '3')
                    {
                        coord.x = x;
                        coord.y = y;
                    }
                    Maz[x][y] = new StringBuilder(c.ToString());
                    x++;
                }

            } while ((!sr.EndOfStream) && (y < max_y));

            sr.Close();
            fs.Close();

            return coord;
        }
        // *** читаем шаблон массива: конец
        // ***** начало программы
        /// <summary>
        /// Create lab
        /// </summary>
        /// <param name="Level">Level of lab</param>
        /// <param name="Capital">Is it Capital</param>
        /// <param name="Quarter">Quarter of capital, default 'Trade Quarter'</param>
        internal static void Create(int Level, bool Capital = false, int Quarter = 0,bool Opening=false)
        {
            // входной файл:
            string input_name = "template.txt";
            // *** читаем размер лабиринта из файла: начало
            FileStream fsr = new FileStream(Directory.GetCurrentDirectory() + "\\template.txt", FileMode.Create);
            StreamWriter sw = new StreamWriter(fsr, Encoding.Default);
            if (!Opening)
            {
                if (!Capital)
                {
                    Biom = DataBase.BiomBase.Random;
                    sw.Write(Biom.Map);
                }
                else
                {
                    switch (Quarter)
                    {
                        case 0: { sw.Write(Template.Capital.TradeQuarter); break; }
                        case 1: { sw.Write(Template.Capital.UndeadQuarter); break; }
                        case 2: { sw.Write(Template.Capital.MageQuarter); break; }
                        case 3: { sw.Write(Template.Capital.BrotherQuarter); break; }
                        case 4: { sw.Write(Template.Capital.RageQuarter); break; }
                    }
                }
            }
            else
            {
                sw.Write(Template.LEARNING);
            }
            sw.Close();
            fsr.Close();
            FileStream fs = new FileStream(Directory.GetCurrentDirectory() + "\\template.txt", FileMode.Open);
            StreamReader sr = new StreamReader(fs, Encoding.Default);
            string str = new string(new char[256]);
            str = sr.ReadLine();
            int max_x = Convert.ToInt32(str);
            str = sr.ReadLine();
            int max_y = Convert.ToInt32(str);
            sr.Close();
            fs.Close();
           
            StringBuilder[][] Maz = new StringBuilder[max_x][];
            
            for (int i = 0; i < max_x; i++)
                Maz[i] = new StringBuilder[max_y];

            TCoord coord = new TCoord(); // координаты входа
            coord = get_shablon(ref Maz, max_x, max_y, ref input_name);
            if (!Opening)
            {
                if (!Capital)
                {
                    generate(ref Maz, max_x, max_y, coord);

                    output(ref Maz, max_x, max_y, Level);
                }
                else
                { output(ref Maz, max_x, max_y, Level, true, Quarter); }
            }
            else
            { output(ref Maz, max_x, max_y, Level, true, Quarter,true); }
            
            for (int i = 0; i < max_x; i++)
                Maz[i] = null;
            Maz = null;
        }

        public static MechEngine.Biom Biom;

        // *** шаблоны
        // ***** начало шаблона
        public static class Template
        {
            public static string RandomTemplate()
            {
                //return Elves.ElvesHoly;
                string rtrn = string.Empty;
                
                switch (r.Next(5))
                {
                    case 0:
                        {
                            rtrn = Template.CrushedAndLab();
                            break;
                        }
                    case 1:
                        {
                            rtrn = Template.ManyHall();
                            break;
                        }
                    case 2:
                        {
                            rtrn = Template.JustLab();
                            break;
                        }
                    case 3:
                        {
                            rtrn = Template.BigHallAndAprt();
                            break;
                        }
                    case 4:
                        {
                            rtrn = Template.RuinedTemple();
                            break;
                        }
                }
                return rtrn;
            }

            public static string CrushedAndLab()
            {
                Postfix = "Руины";
                return
@"72
23
22222222222222222222222222222222222222222222222222222222222222222222222
22002000002222000220222202200002202222222022202222202220022222220222222
22220200022220000222220222220000222220222222222222222222222222222222222
22222222222220222222222222220002222222202222222022222222022222222202222
22222222222222022202222222222000022222222222020002220222222022222022222
20000222222222222222200000220000002222202222222022022222222222222222222
22200002000022222222222002220000002222222222222220222222222222020222222
20222002220002222222222222222222222222222222000222220000022022000000222
20022200002200000002222022222222000022232222222222220200022002220020022
20000002220000000002222000200222000002222222220002220222222220020222222
22220222222222222202222222000222000022222222222220022202222222222000222
22202222022222222222222222220222220222222222022220222222000222220222222
2222222202222222222222222222222220222202220:222222222220222222222220222
20220000000222202022222000020222022222022222222222222222222222020222222
20022222220002022222222222222222022202222202000020220022220222220202222
22220002000200222220000000022222220222222202002220000002222202202222222
20220020222222000020020000202222222222222222202222220222022222202222222
22202202222222022222020020222202202020222220022222222020202222020202222
22222002222222002002022222002222200002002222202222000022200222222222222
222222020202222202202220222002022:2200002202222222222220022222202222222
20220202222022022222222220022202222022022222222222222222022202222222222
20222000002222202222022200202222222200222222220222222222200222002220222
22222222222222222222222222222222222222222222222222222222222222222222222
";
            }

            public static string ManyHall()
            {
                Postfix = "Поселение";
                return
@"72
23
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22220000000000022222222222222222222222222222000000000002222222222222222
22220000000000022222222222222222222222222222000000000002222222222222222
22220000000000022222222222222222222222222222000000000002222222222222222
22220000000000022222222222222222222222222222000000000002222222222222222
22220000000000022222222222222222222222222222000000000002222222222222222
22220000000000022222222222222222222222222222000000000002222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222220000000000022222222222222222222222222222
22222222222222222222222222222220000000000022222222222222222222222222222
22222222222222222222222222222220000030000022222222222222222222222222222
22222222222222222222222222222220000000000022222222222222222222222222222
22222200000000000222222222222220000000000022222222222222222222222222222
22222200000000000222222222222220000000000022222222222222222222222222222
22222200000000000222222222222222222222222222222222222200000000000222222
22222200000000000222222222222222222222222222222222222200000000000222222
22222200000000000222222222222222222222222222222222222200000000000222222
22222200000000000222222222222222222222222222222222222200000000000222222
22222222222222222222222222222222222222222222222222222200000000000222222
22222222222222222222222222222222222222222222222222222200000000000222222
22222222222222222222222222222222222222222222222222222222222222222222222
";
            }

            public static string JustLab()
            {
                Postfix = "Катакомбы";
                return 
@"72
23
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222322222
22222222222222222222222222222222222222222222222222222222222222222222222
";
            }

            public static string BigHallAndAprt()
            {
                Postfix = "Поле боя";
                return 
@"72
23
22222222222222222222222222222222222222222222222222222222222222222222222
22000000000022222222222222222220000000000222222222222222220000000000222
22000000000022222222222222222220000000000222222222222222220000000000222
22000000000022222222222222222220000000000222222222222222220000000000222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222200000000000000000000000000000222222222222222222222
22000000000022222222200000000000000000000000000000222222222222222222222
22000000000022222222200000000000000000000000000000222222222222222222222
22000000000022222222200000000000000000000000000000222222222222222222222
22222222222222222222200000000000000000000000000000222222222000000000022
22222222222222222222200000000000000000000000000000222222222000000000022
22222222222222222222200000000000000000000000000000222222222000000000022
22222222222222222222200000000000000000000000000000222222222222222222222
22222222222222222222200000000000000000000000000000222222222222222222222
22222222222222222222200000000000000000000000000000222222222222222222222
22222222222222222222200000000000000000000000000000222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
22000000000022222222222222222222222222222222222222222222000000000022222
22000030000022222222222222222222222222222222222222222222000000000022222
22000000000022222222222222222222222222222222222222222222000000000022222
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
";
            }

            public static string RuinedTemple()
            {
                Postfix = "Храм";
                return 
@"72
23
22222222222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222220000222222222222222222222222222222222222
22222222222222222222222222220000000000222222222222222222222222222222222
22222222222222222222222220000000000000000222222222222222222222222222222
22222222222222222222222220000000000000000222222222222222220000022222222
22222222222222222222222220000000222000000222222222222222220000022222222
22222222222222222222222220000000222000000222222222222222220000022222222
22222000000000000000000000000000222000000000000000000000000000022222222
22222000000000000000000000000000000000000000000000000000000000022222222
22222222222222222200000222000000000000000022200000222222222222222222222
22222222222222222200000222000000000000000022200000222222222222222222222
22222222222222222200000222000000000000000022200000222222222222222222222
22222222222222222200000000000000000000000000000000222222222222222222222
22222222222222222200000000000000000000000000000000222222222222222222222
22222222222222222222222220000000000000000222222222222222222222222222222
22222222222222222222222222000000000000002222222222222222222222222222222
22222222222222222222222222200000000000022222222222222222222222222222222
22222222222222222222222222220000000000222222222222222222222222222222222
22222222222222222222222222222000000002222222222222222222222222222222222
22222222222222222222222222222200000022222222222222222222222222222222222
22222222222222222222222222222220000222222222222222222222222222222222222
22222222222222222222222222222222002223222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222222222
";
            }

            public static class Capital
            {
                public static string TradeQuarter
                {
                    get
                    {
                        Postfix = "Торговый квартал";
                        return
    @"72
23
#######################################################################
#.................##..##..##..##......................................#
#.###############.##..##..##..##.....########.........................#
#.####.......####.##..##..##..##.....##....##.........##########......#
#..####.....####..##..##..##..##.....##....##.........##......##......#
#...####...####...##..##..##..##..............................##......#
#....####.####....##..##..##..##.....####.............##########......#
#......##.##......##..##..##............#.............................#
#......##.##......##..##......#.#....####.............................#
#.................##..##....###.###...................................#
#########..#########......###.....###.........####.....################
#.......................###.........###...............................#
#.....................................................................#
#.......................###.........###...............................#
#######...................###.....###....#########.....################
#..........###..............###.###.............##.....##.............#
#######....###....#########...#.#.....########..##.....##...########..#
#..........###...........##...........##....##..##.....##.........##..#
#######....###....#########......##...###..###..##................##..#
#..........###...........##......##.............##.....##...########..#
#######....###....#########......##.............##.....##.............#
#........................##......##....................##.............#
#######################################################################
";
                    }
                }

                public static string UndeadQuarter
                {
                    get
                    {
                        Postfix = "Квартал мертвых";
                        return
    @"72
23
#######################################################################
#....................................##...............................#
#.......####......#######............##...........###..........###....#
#......##..##....##.....##...........##..........##.##........##.##...#
#.....##....##..##.......##..........##...........#.#..........#.#....#
#....##......####.........##..........................................#
#...##......####...........##........##......#........................#
#...##.....##..##...........##.......##.....#.#..........###..........#
#...##....##....##...........##......##....#...#........##.##.........#
#...##...##......##.........##.......##....#...............#..........#
#...##..###.......##.......##........##################################
#...##.##.####.######....##.##........................................#
#...##..............####.....##......##################################
#...##.####............##.....##.....##...............................#
#...##....##..########..##.....##....##...............................#
#...##.....####......##..##...##.....##...............................#
#...##......##........##.##..##......##...............................#
#...##.....##........................##...............................#
#...##....####........##.##..##..##..##...............................#
#....##..##..##......##..##..##..##..##...............................#
#.....####....########...##..##..##..##...............................#
#........................##..##..##..##...............................#
#######################################################################
";
                    }
                }

                public static string RageQuarter
                {
                    get
                    {
                        Postfix = "Квартал ярости";
                        return
@"72
23
#######################################################################
#                                                                     #
#    ####                     #####                      ####         #
#  ##    ##                ####   ####                 ##    ##       #
#   ##  ##              ####         ####               ##  ##        #
#                    ####               ####                          #
#                 ####           ####      ####                       #
#              ####            ##    ##       ####                    #
#           ####      ####      ##  ##           ####                 #
###      ####       ##    ##                        ####              #
#         ####       ##  ##                        ####               #
###        ####                      ####         ####                #
#           ####                   ##    ##      ####       ####      #
#            ####     ####          ##  ##      ####      ##    ##    #
#             ####  ##    ##                   ####        ##  ##     #
#   ####       ####  ##  ##                   ####                    #
# ##    ##      ####                         ####                     #
#  ##  ##          ####                   ####                        #
#                     ####             ####                           #
#                                                                     #
#                                                                     #
#                                                                     #
#######################################################################
";
                    }
                }

                public static string BrotherQuarter
                {
                    get
                    {
                        Postfix = "Квартал братства";
                        return
@"72
23
#######################################################################
#                              ##  ##                                 #
#        ########              ##  ##               ########          #
#       ##      ##             ##  ##              ##      ##         #
#      ##        ##            ##  ##            ##         ##        #
#     ##          ##          ##    ##          ##           ##       #
#    ##            ##        ##      ##        ##             ##      #
#    ##             ##########        ##########              ##      #
#    ##             ##                         ##             ##      #
#    ##            ##                           ##            ##      #
#    ##           ##      ######## #######       ##          ##       #
#     ##         ##      ##              ##       ##        ##        #
#      ###### ####      ##                ##       #### #####         #
#       ##                                                ##          #
#        ############   ##                ##   ############           #
#         ##        ##   ##              ##   ##        ##            #
#          ##        ##   ################   ##        ##             #
#           ##        ##                    ##        ##              #
#            ##                                      ##               #
#             ##      ##                    ##      ##                #
#              ######################################                 #
#                                                                     #
#######################################################################
";
                    }
                }

                public static string MageQuarter
                {
                    get
                    {
                        Postfix = "Квартал магов";
                        return
@"72
23
#######################################################################
#                                                                     #
#      ##########################################################     #
#    ##                           M                              ##   #
#   ## Y                                                       N  ##  #
#    ##  ######################################################  ##   #
#      ##                                                      ##     #
#                ##              ##                                   #
#              ## M##          ## M##              ##                 #
#    ##       ##  W ##        ##  E ##           ##  ##  ##############
#  ## M##      ##  ##          ##  ##          ##      ############   #
# ##    ##       ##              ##            ##  M                  #
#  ##F ##                 ##                   ##      ############   #
#    ##                 ## M##                   ##  ##  ##############
#                      ##    ##                    ##                 #
#                       ## A##                                        #
#      ##########################################################     #
#    ##  ##                        M                             ##   #
#   ##  T                                                       B ##  #
#    ##  ######################################################  ##   #
#      ##                                                      ##     #
#                                                                     #
#######################################################################
";
                    }
                }
            }

            public static string LEARNING
            {
                get
                {
                    Postfix = "Частилище";
                    return
@"72
23
#######################################################################
#                              ##  ##                                 #
#        ########              ##  ##               ########          #
#       ##      ##             ##  ##              ##      ##         #
#      ##        ##            ##  ##            ##         ##        #
#     ##          ##          ##    ##          ##           ##       #
#    ##            ##        ##      ##        ##             ##      #
#    ##             ##########        ##########              ##      #
#    ##             ##                         ##             ##      #
#    ##            ##                           ##            ##      #
#    ##           ##      ######## #######       ##          ##       #
#     ##         ##      ##              ##       ##        ##        #
#      ###### ####      ##                ##       #### #####         #
#       ##                                                ##          #
#        ############   ##                ##   ############           #
#         ##        ##   ##              ##   ##        ##            #
#          ##        ##   ################   ##        ##             #
#           ##        ##                    ##        ##              #
#            ##                                      ##               #
#             ##      ##                    ##      ##                #
#              ######################################                 #
#                                                                     #
#######################################################################
";
                }

            }

            public static string Postfix;
        }
        /// <summary>
        /// All int-value mean quarter
        /// </summary>
        public static class CapitalEngine
        {
            /// <summary>
            /// Create npc
            /// </summary>
            public static int CreateNpc
            {
                set
                {
                    MechEngine.Labirinth l = Rogue.RAM.Map;
                    switch (value)
                    {
                        #region Trade
                        case 0:
                            {
                                l.Map[28][11].Object = DataBase.ObjectBase.CapitalHpFountain; //31
                                l.Map[29][10].Object = DataBase.ObjectBase.SelfChest; //Личный сундук
                                l.Map[33][10].Object = DataBase.ObjectBase.WorldKeeper; //Дипломат
                                l.Map[34][11].Object = DataBase.ObjectBase.CapitalMpFountain; //31
                                if (!Rogue.RAM.Flags.VirgilEnd) { l.Map[29][14].Object = DataBase.NpcBase.Vergiliy; }//Вирджил

                                l.Map[38][20].Object = DataBase.NpcBase.Qurel;
                                l.Map[42][17].Object = DataBase.NpcBase.Lir;
                                l.Map[66][18].Object = DataBase.NpcBase.Rutger;
                                l.Map[55][12].Object = DataBase.NpcBase.Cat;
                                l.Map[60][4].Object = DataBase.NpcBase.Polus;
                                l.Map[38][7].Object = DataBase.NpcBase.Ella;
                                l.Map[3][15].Object = DataBase.NpcBase.Tot;
                                l.Map[16][17].Object = DataBase.NpcBase.Anu;
                                if (Rogue.RAM.Player.Class != MechEngine.BattleClass.Valkyrie)
                                {
                                    l.Map[13][21].Object = DataBase.NpcBase.Bas;
                                }
                                l.Map[42][3].Object = DataBase.NpcBase.Simantek;
                                l.Map[20][0].Object = DataBase.DoorBase.UndeadDoor;
                                l.Map[21][0].Object = DataBase.DoorBase.UndeadDoor;
                                l.Map[24][0].Object = DataBase.DoorBase.UndeadDoor;
                                l.Map[25][0].Object = DataBase.DoorBase.UndeadDoor;
                                l.Map[28][0].Object = DataBase.DoorBase.UndeadDoor;
                                l.Map[29][0].Object = DataBase.DoorBase.UndeadDoor;
                                l.Map[0][11].Object = DataBase.DoorBase.MagicalDoor;
                                l.Map[0][12].Object = DataBase.DoorBase.MagicalDoor;
                                l.Map[0][13].Object = DataBase.DoorBase.MagicalDoor;
                                l.Map[29][22].Object = DataBase.DoorBase.HumanDoor;
                                l.Map[30][22].Object = DataBase.DoorBase.HumanDoor;
                                l.Map[70][11].Object = DataBase.DoorBase.OrcDoor;
                                l.Map[70][12].Object = DataBase.DoorBase.OrcDoor;
                                l.Map[70][13].Object = DataBase.DoorBase.OrcDoor;
                                l.Map[9][3].Object = DataBase.DoorBase.Exit;
                                if (Rogue.RAM.InPortal != null)
                                { l.Map[3][8].Object = DataBase.DoorBase.TownPortal; }
                                break;
                            }
                        #endregion
                        #region Undead
                        case 1:
                            {
                                l.Map[27][22].Object = DataBase.DoorBase.TradeDoor;
                                l.Map[28][22].Object = DataBase.DoorBase.TradeDoor;
                                l.Map[31][22].Object = DataBase.DoorBase.TradeDoor;
                                l.Map[32][22].Object = DataBase.DoorBase.TradeDoor;
                                l.Map[35][22].Object = DataBase.DoorBase.TradeDoor;
                                l.Map[36][22].Object = DataBase.DoorBase.TradeDoor;

                                if (Rogue.RAM.Flags.Stephan) { l.Map[51][3].Object = DataBase.NpcBase.Stephan; }

                                if ((Rogue.RAM.Flags.Stephan && !Rogue.RAM.Flags.Valery) || (Rogue.RAM.Flags.Valery & !Rogue.RAM.Flags.Stephan))
                                { l.Map[45][8].Object = DataBase.MembersBase.Undead; }

                                l.Map[64][3].Object = DataBase.NpcBase.Gregory;

                                if (Rogue.RAM.Flags.Valery) { l.Map[58][8].Object = DataBase.NpcBase.Valery; }

                                l.Map[70][11].Object = DataBase.DoorBase.OrcDoor;
                                l.Map[14][9].Object = DataBase.NpcBase.Rector;
                                l.Map[10][5].Object = DataBase.NpcBase.Sara;
                                l.Map[9][16].Object = DataBase.NpcBase.Klara;
                                l.Map[18][17].Object = DataBase.NpcBase.Wilyam;
                                l.Map[21][5].Object = DataBase.NpcBase.Biblio;
                                l.Map[24][8].Object = DataBase.NpcBase.BiblioHelper;

                                if (Rogue.RAM.Flags.SaraHelp) { Rogue.RAM.Map.Map[9][11].Wall = new MechEngine.Wall(); Rogue.RAM.Map.Map[9][11].Vision = '#'; }

                                int y = 0;
                                switch (Rogue.RAM.Flags.UndeadRising)
                                {
                                    case 0: {y = 56; break; }
                                    case 1: { y = 60; break; }
                                    case 2: {  y = 64; break; }
                                    case 3: { y = 70; break; }
                                    case 4: {  y = 1; break; }
                                }
                                for (int i = 16; i < 20; i++)
                                {
                                    for (int q = 51; q < y; q++)
                                    {
                                        l.Map[q][i].Object = DataBase.NpcBase.Grave;
                                        if (Rogue.RAM.Flags.UndeadRising == 4)
                                        { //Rector
                                        }
                                    }
                                }
                                break;
                            }
                        #endregion
                        #region Mage
                        case 2:
                            {
                                l.Map[34][3].Object = DataBase.NpcBase.GateKeeperMage;
                                l.Map[6][10].Object = DataBase.NpcBase.GateKeeperMage;
                                l.Map[18][8].Object = DataBase.NpcBase.GateKeeperMage;
                                l.Map[34][8].Object = DataBase.NpcBase.GateKeeperMage;
                                l.Map[27][13].Object = DataBase.NpcBase.GateKeeperMage;
                                l.Map[39][17].Object = DataBase.NpcBase.GateKeeperMage;
                                l.Map[53][11].Object = DataBase.NpcBase.GateKeeperMage;

                                l.Map[70][10].Object = DataBase.DoorBase.TradeDoor;
                                l.Map[70][11].Object = DataBase.DoorBase.TradeDoor;
                                l.Map[70][12].Object = DataBase.DoorBase.TradeDoor;

                                l.Map[7][4].Object = DataBase.NpcBase.Yellow;
                                l.Map[63][4].Object = DataBase.NpcBase.Nation;
                                l.Map[8][18].Object = DataBase.NpcBase.Travor;
                                l.Map[64][18].Object = DataBase.NpcBase.Behavor;

                                l.Map[5][12].Object = DataBase.NpcBase.Folk;
                                l.Map[18][9].Object = DataBase.NpcBase.Ward;
                                l.Map[34][9].Object = DataBase.NpcBase.Eart;
                                l.Map[27][15].Object = DataBase.NpcBase.Ange;
                                break;
                            }
                        #endregion
                        #region Human
                        case 3:
                            {
                                //l.Map[33][0].Object = DataBase.DoorBase.TradeDoor;
                                //l.Map[34][0].Object = DataBase.DoorBase.TradeDoor;
                                //l.Map[31][7].Object = DataBase.NpcBase.HumanGuardian;
                                //l.Map[36][7].Object = DataBase.NpcBase.HumanGuardian;
                                //l.Map[33][9].Object = DataBase.NpcBase.HumanGuardian;
                                //l.Map[35][9].Object = DataBase.NpcBase.HumanGuardian;
                                //l.Map[31][13].Object = DataBase.NpcBase.HumanGuardian;
                                //l.Map[37][13].Object = DataBase.NpcBase.HumanGuardian;
                                //l.Map[34][13].Object = DataBase.NpcBase.Nadin;
                                //l.Map[11][6].Object = DataBase.NpcBase.Hostes;
                                //l.Map[54][6].Object = DataBase.NpcBase.Hostes;
                                //l.Map[15][10].Object = DataBase.NpcBase.Hostes;
                                //l.Map[58][10].Object = DataBase.NpcBase.Hostes;
                                //l.Map[16][15].Object = DataBase.NpcBase.Hostes;
                                //l.Map[35][18].Object = DataBase.NpcBase.Hostes;
                                //l.Map[50][18].Object = DataBase.NpcBase.Hostes;
                                //l.Map[13][8].Object = DataBase.NpcBase.LordKing;
                                //l.Map[56][7].Object = DataBase.NpcBase.LordMagnus;
                                //l.Map[18][17].Object = DataBase.NpcBase.LordPraud;
                                //l.Map[52][15].Object = DataBase.NpcBase.LordServant;
                                break;
                            }
                        #endregion
                        #region Rage
                        case 4:
                            {
                                //l.Map[0][10].Object = DataBase.DoorBase.UndeadDoor;
                                //l.Map[0][19].Object = DataBase.DoorBase.TradeDoor;
                                //l.Map[0][20].Object = DataBase.DoorBase.TradeDoor;
                                //l.Map[0][21].Object = DataBase.DoorBase.TradeDoor;
                                //l.Map[7][3].Object = DataBase.NpcBase.GoblinKing;
                                //l.Map[5][16].Object = DataBase.NpcBase.TrollKing;
                                //l.Map[59][3].Object = DataBase.NpcBase.StoneOrcKing;
                                //l.Map[62][13].Object = DataBase.NpcBase.ZetKing;
                                //l.Map[35][7].Object = DataBase.NpcBase.OrcShaman;
                                //l.Map[23][9].Object = DataBase.NpcBase.OrcMage;
                                //l.Map[31][11].Object = DataBase.NpcBase.OrcKing;
                                //l.Map[39][12].Object = DataBase.NpcBase.OrcRogue;
                                //l.Map[23][14].Object = DataBase.NpcBase.OrcWar;
                                break;
                            }
                        #endregion
                    }
                }
            }
            /// <summary>
            /// Create character position
            /// </summary>
            public static int CreateChar
            {
                set
                {
                    switch (value)
                    {
                        case 0: { Rogue.RAM.Map.Map[31][12].Player = Rogue.RAM.Player; Rogue.RAM.Map.Map[29][12].Vision = Rogue.RAM.Player.Icon; break; }
                        case 1: { Rogue.RAM.Map.Map[34][11].Player = Rogue.RAM.Player; Rogue.RAM.Map.Map[34][11].Vision = Rogue.RAM.Player.Icon; break; }
                        case 2: { Rogue.RAM.Map.Map[68][11].Player = Rogue.RAM.Player; Rogue.RAM.Map.Map[34][11].Vision = Rogue.RAM.Player.Icon; break; }
                        case 3: { Rogue.RAM.Map.Map[34][10].Player = Rogue.RAM.Player; Rogue.RAM.Map.Map[34][10].Vision = Rogue.RAM.Player.Icon; break; }
                        case 4: { Rogue.RAM.Map.Map[32][20].Player = Rogue.RAM.Player; Rogue.RAM.Map.Map[32][20].Vision = Rogue.RAM.Player.Icon; break; }
                    }
                }
            }

            public static void CharLEARN()
            {
                Rogue.RAM.Map.Map[34][10].Player = Rogue.RAM.Player; Rogue.RAM.Map.Map[34][10].Vision = Rogue.RAM.Player.Icon;
            }
            public static void NpcLEARN()
            {
                MechEngine.Labirinth l = Rogue.RAM.Map;
                l.Map[31][7].Object = DataBase.NpcBase.Angel;
                l.Map[36][7].Object = DataBase.NpcBase.Angel;
                l.Map[33][9].Object = DataBase.NpcBase.Angel;
                l.Map[35][9].Object = DataBase.NpcBase.Angel;
                l.Map[31][13].Object = DataBase.NpcBase.Angel;
                l.Map[37][13].Object = DataBase.NpcBase.Angel;
                l.Map[34][13].Object = DataBase.NpcBase.Keeper;
                l.Map[11][6].Object = DataBase.NpcBase.Angel;
                l.Map[54][6].Object = DataBase.NpcBase.Angel;
                l.Map[15][10].Object = DataBase.NpcBase.Angel;
                l.Map[58][10].Object = DataBase.NpcBase.Angel;
                l.Map[16][15].Object = DataBase.NpcBase.Angel;
                l.Map[35][18].Object = DataBase.NpcBase.Angel;
                l.Map[50][18].Object = DataBase.NpcBase.Angel;
                l.Map[13][8].Object = DataBase.NpcBase.Angel;
                l.Map[56][7].Object = DataBase.NpcBase.Angel;
                l.Map[18][17].Object = DataBase.NpcBase.Angel;
                l.Map[52][15].Object = DataBase.NpcBase.Angel;
            }
        }

        // *** ENGINE
        // ***** Enemy, Char, e.t.c
        public static class CharEnemyLootEngine
        {
            private static Random r = new Random();
            public static void CreateCharacter()
            {
                Random r = new Random(DateTime.Now.Second);
                var Lab = Rogue.RAM.Map;
                bool once = false;
                for (int y = r.Next(22); y < 23; y++)
                {
                    for (int x = r.Next(68); x < 71; x++)
                    {
                        if (once == false)
                        {
                            if (Lab.Map[x][y].Vision != '#' && Lab.Map[x][y].Enemy == null && Lab.Map[x][y].Item == null)
                            {
                                Lab.Map[x][y].Player = Rogue.RAM.Player;
                                Lab.Map[x][y].Vision =  Rogue.RAM.Player.Icon;
                                once = true;
                            }
                        }
                    }
                }
            }
            /// <summary>
            /// CARE! TESTS
            /// </summary>
            public static void CreateEnemys()
            {
                //int Enemys = Level*3;
                int i = 0;
                var Lab = Rogue.RAM.Map;
                bool full = false;
                bool next = false;
                while (!full)
                {
                    next = false;
                    int suka = r.Next(22);
                    int omg = r.Next(70);                    
                    for (int y = suka; y < 23; y++)
                    {
                        for (int x = omg; x < 71; x++)
                        {
                            if (!next)
                            {
                                if (!full)
                                {
                                    if (Lab.Map[x][y].Vision != '#')
                                    {
                                        Lab.Map[x][y].Enemy = DataBase.MobBase.GetMob();//Lab.Map[x][y].Enemy = DataBase.MobBase.m[i];//
                                        i++;
                                        next = true;
                                        int max = Rogue.RAM.Map.Level * 3;
                                        //if (max > DataBase.MobBase.m.Count) { max = DataBase.MobBase.m.Count; } //max>12; max=12
                                        if (max > 12) { max = 12; }
                                        if (i == max) { full = true; }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            public static void CreateItems()
            {
                int Items = Rogue.RAM.Player.Level * 5;
                var Lab = Rogue.RAM.Map;
                
                Thread.Sleep(100);            
                bool creates=true;
                int count=0;
                while (creates)
                {
                    int q = r.Next(22);
                    int w = r.Next(70);

                    if (Lab.Map[w][q].Vision != '#' && Lab.Map[w][q].Enemy == null)
                    {
                        Lab.Map[w][q].Item = DataBase.ItemBase.GetItem;
                        int max = Rogue.RAM.Map.Level;
                        if (max > 15) { max = 15; }
                        if (count == max) { creates = false; }
                        count++;
                    }
                }
            }

            public static void CreateEnterOuter()
            {
                
                var Lab = Rogue.RAM.Map;
                bool once = true;
                while (once)
                {
                    int x = r.Next(68);
                    int y = r.Next(22);
                    if (Lab.Map[x][y].Vision != '#' && Lab.Map[x][y].Enemy == null && Lab.Map[x][y].Item == null)
                    {
                        MechEngine.ActiveObject e = new MechEngine.ActiveObject();
                        e.Name = "Exit";
                        Lab.Map[x][y].Object = e;
                        once = false;
                    }
                }
            }

            public static void CreateDoors()
            {
                int Doors = 0;
                var Lab = Rogue.RAM.Map;
                bool Merchant = false;
                //bool Questgiver = false;
                bool creates = true;

                while (creates)
                {
                    int x = r.Next(68);
                    int y = r.Next(22);
                    int q = r.Next(2);
                    int h = r.Next(2);

                    if (Lab.Map[x][y].Vision != '#' && Lab.Map[x][y].Enemy == null && Lab.Map[x][y].Item == null && Lab.Map[x][y].Object == null && Lab.Map[x][y].Player == null)// && (((Lab.Map[x + 1][y].Wall != null && Lab.Map[x][y + 1].Wall == null) || (Lab.Map[x - 1][y].Wall != null && Lab.Map[x][y - 1].Wall == null)) || ((Lab.Map[x][y + 1].Wall != null && Lab.Map[x + 1][y].Wall == null) || (Lab.Map[x][y - 1].Wall != null && Lab.Map[x - 1][y].Wall == null))))
                    {
                        if (
                            (Lab.Map[x + 1][y].Wall != null && Lab.Map[x - 1][y].Wall != null) && (Lab.Map[x][y + 1].Wall == null && Lab.Map[x][y - 1].Wall == null)
                            ||
                            (Lab.Map[x][y + 1].Wall != null && Lab.Map[x - 1][y - 1].Wall != null) && (Lab.Map[x + 1][y].Wall == null && Lab.Map[x - 1][y].Wall == null)
                            )
                        {
                            Lab.Map[x][y].Object = DataBase.DoorBase.GetDoor(q);
                            if (Doors == 7) { creates = false; }
                            Doors++;
                        }
                        else
                        {
                            if (!Merchant && (r.Next(5) == 1))
                            { Lab.Map[x][y].Object = DataBase.MerchantBase.GetMerchant; Merchant = true; }
                            else { Merchant = true; }
                        }
                    }
                }
            }

            public static void CreatePoisons()
            {
                if (Rogue.RAM.Player.Class == MechEngine.BattleClass.Assassin)
                {
                    
                    int Doors = 0;
                    int Ceiling = Rogue.RAM.Player.Level;
                    if (Ceiling > 10) { Ceiling = 10; }
                    var Lab = Rogue.RAM.Map;
                    bool once = false;
                    while (Doors != Ceiling)
                    {
                        for (int y = r.Next(22); y < 23; y++)
                        {
                            for (int x = r.Next(68); x < 71; x++)
                            {
                                if (Doors != Ceiling)
                                {
                                    if (once == false)
                                    {
                                        if (Lab.Map[x][y].Vision==' ')
                                        {
                                            Lab.Map[x][y].Item = new MechEngine.Item.Poison();
                                            Thread.Sleep(10);
                                            once = true;
                                            Doors++;
                                        }
                                    }
                                }
                            }
                        }
                        once = false;
                    }
                }
            }

            public static void CreateBosses()
            {
                var Lab = Rogue.RAM.Map;
                if ((Rogue.RAM.Map.Level % 2) != 0)
                {
                    int q = r.Next(22);
                    int w = r.Next(70);
                    if (r.Next(50) <= 10)
                    {
                        if (Lab.Map[w][q].Vision != '#' && Lab.Map[w][q].Item == null && Lab.Map[w][q].Player == null && Lab.Map[w][q].Object == null)
                        {
                            Lab.Map[w][q].Enemy = DataBase.MobBase.GetBoss;                            
                        }
                    }
                }
            }

            public static void CreateObjects()
            {
                var Lab = Rogue.RAM.Map;
                for (int i = 0; i < 3; i++)
                {
                    int q = r.Next(22);
                    int w = r.Next(70);
                    if (r.Next(50) <= 10)
                    {
                        if (Lab.Map[w][q].Vision != '#' && Lab.Map[w][q].Enemy == null && Lab.Map[w][q].Item==null && Lab.Map[w][q].Player==null && Lab.Map[w][q].Object==null)
                        {
                            Lab.Map[w][q].Object = DataBase.UsableObjects.RandomObject;
                        }
                    }
                }
            }

            public static void CreateBiom()
            {
                Rogue.RAM.Map.Biom = Biom.Color;
                Rogue.RAM.Map.Name = Biom.Name + " - " + Biom.Affix;
                Rogue.RAM.Map._Name = Biom.Name;
                Rogue.RAM.Map._Affics = Biom.Affix;

                //Rogue.RAM.Map._Affics = Biom.Affix;
                //switch (r.Next(6))
                //{
                //    case 0:
                //        {
                //            Rogue.RAM.Map.Biom = ConsoleColor.DarkCyan;
                //            Rogue.RAM.Map.Name = "Инеистая гора - " + Biom.Affix;
                //            Rogue.RAM.Map._Name = "Инеистая гора";
                //            break;
                //        }
                //    case 1:
                //        {
                //            Rogue.RAM.Map.Biom = ConsoleColor.DarkGreen;
                //            Rogue.RAM.Map.Name = "Древо мира - " + Biom.Affix;
                //            Rogue.RAM.Map._Name = "Древо мира";
                //            break;
                //        }
                //    case 2:
                //        {
                //            Rogue.RAM.Map.Biom = ConsoleColor.DarkYellow;
                //            Rogue.RAM.Map.Name = "Материк демонов - " + Biom.Affix;
                //            Rogue.RAM.Map._Name = "Материк демонов";
                //            break;
                //        }
                //    case 3:
                //        {
                //            Rogue.RAM.Map.Biom = ConsoleColor.Gray;
                //            Rogue.RAM.Map.Name = "Пещеры дварфов - " + Biom.Affix;
                //            Rogue.RAM.Map._Name = "Пещеры дварфов";
                //            break;
                //        }
                //    case 4:
                //        {
                //            Rogue.RAM.Map.Biom = ConsoleColor.DarkMagenta;
                //            Rogue.RAM.Map.Name = "Подземелья дроу - " + Biom.Affix;
                //            Rogue.RAM.Map._Name = "Подземелья дроу";
                //            break;
                //        }
                //    case 5:
                //        {
                //            Rogue.RAM.Map.Biom = ConsoleColor.DarkGray;
                //            Rogue.RAM.Map.Name = "Мертвые земли - " + Biom.Affix;
                //            Rogue.RAM.Map._Name = "Мертвые земли";
                //            break;
                //        }
                //}
                
            }

            public static void MoveObjects(string Coord)
            {

            }
        }
    }
    // описываем структуру для хранения входных данных: конец
    // *** описание списка: начало
    // координаты на плоскости:
    public class TCoord
    {
        public int x;
        public int y;
    }
    // элемент списка:
    public class node : ICloneable
    {
        public TCoord coord = new TCoord(); // каждый элемент хранит координаты соответствующего поля лабиринта
        public node next; // и указатель на следующий элемент
        public object Clone()
        {
            return this.MemberwiseClone();
        }
    }
    // список:
    public class TList
    {
        public node head; // указатели на начало списка и на конец
        public node tail;
        public int nodes_num; // количество элементов списка
        public TList() // инициализация указателей как пустых
        {
            head = null;
            tail = null;
            nodes_num = 0;
        }
        // * деструктор для освобождения памяти от списка: начало
        public void Dispose()
        {
            node temp = head; // временный указатель на начало списка
            while (temp != null) // пока в списке что-то есть
            {
                temp = head.next; // резерв адреса на следующий элемент списка
                head = null; // освобождение памяти от первой структуры как элемента списка
                head = temp; // сдвиг начала на следующий адрес, который берем из резерва
            }
        }
        // * деструктор для освобождения памяти от списка: конец
        // * добавление элемента в список: начало
        public void add_node(int x, int y) // функция добавления элемента
        {
            node temp = new node(); //Выделение памяти для нового звена списка
            temp.coord.x = x; // временное запоминание принятых параметров
            temp.coord.y = y;
            temp.next = null; // следующее звено новосозданной структуры пока пустое
            if (head != null) // если список не пуст
            {
                tail.next = temp; // следующее звено списка это новосозданная структура
                tail = temp; // и теперь хвост указывает на новое звено
            }
            else
                head = tail = temp; // если список пуст, добавление первого элемента
            // наращиваем количество элементов в списке:
            nodes_num++;
        }
        // * добавление элемента в список: конец
        // * выбор элемента по номеру в списке: начало
        public TCoord get_node(int n)
        {
            // заводим вспомогательные переменные:
            //C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
            node pnode = new node();
            int i;
            TCoord coord = new TCoord();
            // становимся на нулевой элемент списка:
            //C++ TO C# CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a "CopyFrom" method should be created if it does not yet exist:
            //ORIGINAL LINE: pnode = head;
            //pnode = new node(head);
            pnode = (node)head.Clone();
            i = 0;
            // перебираем список, пока не дойдём до нужного элемента:
            while ((pnode != null) && (i < n))
            {
                //C++ TO C# CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a "CopyFrom" method should be created if it does not yet exist:
                //ORIGINAL LINE: pnode = pnode->next;
                pnode = (node)pnode.next.Clone();
                //pnode. //CopyFrom(pnode.next);
                i++;
            }
            // если нужный элемент существует:
            if (pnode != null)
            {
                // берём данные из нужного элемента:
                coord.x = pnode.coord.x;
                coord.y = pnode.coord.y;
            }
            else // иначе
            {
                // подставляем (-1,-1) как код ошибки:
                coord.x = -1;
                coord.y = -1;
                // но вообще такого быть не должно-
                // мы будем запрашивать только корректные номера
            }
            // возвращаем координаты элемента:
            return coord;
        }
        // * выбор элемента по номеру в списке: конец
        // * удаление элемента из списка по его номеру: начало
        public void del_node(int n, TList list)
        {
            // заводим вспомогательные переменные:
            node curr_node;
            node prev_node;
            int i;
            // если нужно удалить нулевой элемент,
            if (n == 0)
            {
                // то просто удаляем его:
                curr_node = head.next;
                // если этот элемент был последним,
                // то надо поправить хвост:
                if (tail == head)
                    tail = null;

                head = null;
                // поправляем голову списка:
                head = curr_node;
                // уменьшаем количество элементов в списке:
                nodes_num--;
                // конец функции:
                return;
            }
            // становимся на нулевой элемент списка:
            curr_node = head;
            i = 0;
            do
            {
                // перебираем список:
                prev_node = curr_node;
                curr_node = curr_node.next;
                i++;
                // пока не дойдём до нужного элемента:
            } while ((curr_node != null) && (i < n));
            // если нужный элемент существует:
            if (curr_node != null)
            {
                // если он последний, то поправляем хвост списка:
                if (curr_node == tail)
                    tail = prev_node;
                // предыдущий элемент должен теперь указывать на следующий:
                prev_node.next = curr_node.next;
                // удаляем:
                curr_node = null;
                // уменьшаем количество элементов в списке:
                nodes_num--;
            }
            return;
        }
        // * удаление элемента из списка по его номеру: конец
    }
    // ***** конец программы
    //----------------------------------------------------------------------------------------
    //	Copyright © 2006 - 2008 Tangible Software Solutions Inc.
    //
    //	This class provides the ability to simulate the behavior of the C/C++ functions for 
    //	generating random numbers, using the .NET Framework System.Random class.
    //	"rand" converts to the parameterless overload of NextNumber
    //	"random" converts to the single-parameter overload of NextNumber
    //	"randomize" converts to the parameterless overload of Seed
    //	"srand" converts to the single-parameter overload of Seed
    //----------------------------------------------------------------------------------------
    internal static class RandomNumbers
    {
        private static System.Random r;

        internal static int NextNumber()
        {
            if (r == null)
                Seed();

            return r.Next();
        }

        internal static int NextNumber(int ceiling)
        {
            if (r == null)
                Seed();

            return r.Next(ceiling);
        }

        internal static void Seed()
        {
            r = new System.Random();
        }

        internal static void Seed(int seed)
        {
            r = new System.Random(seed);
        }
    }
    //----------------------------------------------------------------------------------------
    //	Copyright © 2006 - 2008 Tangible Software Solutions Inc.
    //
    //	This class provides miscellaneous helper methods for strings.
    //----------------------------------------------------------------------------------------
    internal static class StringHelper
    {
        //------------------------------------------------------------------------------------
        //	This method allows replacing a single character in a string, to help convert
        //	C++ code where a single character in a character array is replaced.
        //------------------------------------------------------------------------------------
        internal static string ChangeCharacter(string sourcestring, int charindex, char changechar)
        {
            return (charindex > 0 ? sourcestring.Substring(0, charindex) : "")
                + changechar.ToString() + (charindex < sourcestring.Length - 1 ? sourcestring.Substring(charindex + 1) : "");
        }
    }
}